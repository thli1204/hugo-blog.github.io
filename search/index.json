[{"content":"简单实现ReentrantLock 实现思路 锁的基本执行流程：\n抢到锁，继续执行 抢不到锁，阻塞等待 释放锁，唤醒等待线程抢锁 所以需要一个互斥量\n释放锁时需要唤醒等待线程，所以需要一个存储等待线程的集合：\n使用线程安全的集合 使用链表 代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 public class MyReentrantLock implements Lock { /** * 锁的基本使用流程 * \u0026lt;br\u0026gt; * 抢到锁,继续执行 * \u0026lt;br\u0026gt; * 抢不到锁,阻塞等待 * \u0026lt;br\u0026gt; * 释放锁,唤醒等待线程执行 */ private volatile int status; private volatile Thread ownThread; /** * 链表节点 */ private static class Node { Thread thread; volatile Node pre; volatile Node next; public Node(Thread thread) { this.thread = thread; } } /** * 头结点 */ private volatile Node head; /** * 尾结点 */ private volatile Node tail; private boolean fair; public MyReentrantLock() { } public MyReentrantLock(boolean fair) { this.fair = fair; } /** * 使用线程安全的List记录等待线程 */ private volatile CopyOnWriteArrayList\u0026lt;Thread\u0026gt; waitThreads = new CopyOnWriteArrayList\u0026lt;\u0026gt;(); private static final AtomicIntegerFieldUpdater\u0026lt;MyReentrantLock\u0026gt; ATOMIC_INTEGER_FIELD_UPDATER = AtomicIntegerFieldUpdater.newUpdater(MyReentrantLock.class, \u0026#34;status\u0026#34;); private static final AtomicReferenceFieldUpdater\u0026lt;MyReentrantLock, Node\u0026gt; HEAD_ATOMIC_FIELD = AtomicReferenceFieldUpdater.newUpdater(MyReentrantLock.class, Node.class, \u0026#34;head\u0026#34;); private static final AtomicReferenceFieldUpdater\u0026lt;MyReentrantLock, Node\u0026gt; TAIL_ATOMIC_FIELD = AtomicReferenceFieldUpdater.newUpdater(MyReentrantLock.class, Node.class, \u0026#34;tail\u0026#34;); @Override public void lock() { //可重入判断 if (Thread.currentThread() == ownThread) { status++; return; } //判断是否为公平模式 if (fair) { Node node = waitThread(); doPark(node); } else { if (!tryLock()) { //加入等待队列 // waitThreads.add(Thread.currentThread()); Node node = waitThread(); //使用循环,如果抢到锁,结束,没有继续循环阻塞等待 doPark(node); } } } private void doPark(Node node) { while (true) { //如果是第一个节点,尝试获取锁 //防止 /* head=null;tail=null; t1 lock成功 t1 unlock 此时head=null t2 waitThread() t1 unlock return 此时t2线程不会被唤醒(除非有其他线程来抢锁) */ if (node.pre == head) { if (tryLock()) { //抢到锁,从等待队列中删除该线程 head.next = null; head = node; node.thread = null; node.pre = null; //waitThreads.remove(Thread.currentThread()); return; } } LockSupport.park(this); //被唤醒后,清除中断状态,否则循环再次进来park不成功 Thread.interrupted(); } } private Node waitThread() { Node node = new Node(Thread.currentThread()); while (true) { Node t = tail; //如果为空,初始化链表 if (t == null) { if (HEAD_ATOMIC_FIELD.compareAndSet(this, null, new Node(null))) { tail = head; //完成了链表的初始化,重复循环,将节点加入到尾 } } else { node.pre = t; if (TAIL_ATOMIC_FIELD.compareAndSet(this, t, node)) { t.next = node; return node; } } } } @Override public void lockInterruptibly() throws InterruptedException { } @Override public boolean tryLock() { /* 需要一个互斥量 通过一个int属性,CAS操作compareAndSet(0,1)充当互斥量,抢到锁,设置成功 方式1:使用字段属性的原子类 方式2:使用原子类AtomicInteger */ //方式1 boolean b = ATOMIC_INTEGER_FIELD_UPDATER.compareAndSet(this, 0, 1); //记录抢到锁的线程 if (b) { ownThread = Thread.currentThread(); } return b; } @Override public boolean tryLock(long time, TimeUnit unit) throws InterruptedException { return false; } @Override public void unlock() { //unlock设置status为0,从等待队列中唤醒一个等待线程抢锁 //等待队列:1.可以使用链表 2.可以使用线程安全的集合 if (ownThread == Thread.currentThread()) { int s = status - 1; if (s == 0) { ownThread = null; } status = s; //使用链表 Node h = head; if (h != null) { Node n = h.next; if (n != null) { LockSupport.unpark(n.thread); } } } } @Override public Condition newCondition() { return null; } } ","date":"2022-04-15T00:00:00Z","permalink":"https://www.gpanda.me/p/%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0reentrantlock/","title":"简单实现ReentrantLock"},{"content":"手写线程池 线程状态 NEW：新创建的线程，尚未执行； RUNNABLE：运行中的线程，正在执行run()方法的Java代码；start()后的状态 BLOCKED：运行中的线程，因为某些操作被阻塞而挂起； WAITING：运行中的线程，因为某些操作在等待中，这种状态的线程不会被分配CPU执行时间，它们要等待被显式地唤醒，否则会处于无限期等待的状态； TIMED_WAITING：运行中的线程，因为执行sleep()方法正在计时等待； TERMINATED：线程已终止，因为run()方法执行完毕； 线程状态的转换 sleep时处于什么状态 WAITING或者TIMED_WAITING，但是不释放锁\nJoin时处于什么状态 WAITING或者TIMED_WAITING\nWait时处于什么状态 WAITING，同时会释放锁\n抢不到锁时处于什么状态 BLOCKED\n等待IO RUNNABLE\n线程终止 为什么不使用stop\n不安全，会立马释放所持有的锁，会导致被保护资源不一致，使程序结果不确定\n正确的终止线程：\n使用violate boolean变量来标识线程是否终止 停止线程时，需要调用停止线程的interrupt()方法，因为线程可能在wait或者sleep，提高停止线程的及时性 对于blocking IO的处理，尽量使用InterruptibleChannel来代替blocking IO 为什么需要线程池 线程在Java中是一个对象，每一个Java线程都需要一个操作系统线程支持。线程的创建，销毁需要时间。如果创建时间+销毁时间\u0026gt;执行任务的时间，就很不合算 Java对象占用堆内存，操作系统内存占用系统内存，根据JVM规范，一个线程最大栈大小为1M，这个栈空间是需要从操作系统内存中分配的。创建的线程过多，会消耗极大的内存。 操作系统需要拼频繁的切换线程上下文，影响性能。 线程池工作原理 接收任务，放入任务仓库 工作线程从任务仓库取任务执行 当没有任务时，线程阻塞，当有任务时，唤醒线程执行 手写线程池 问题 任务用什么表示 Runnable Callable 仓库用什么表示 BlockingQueue阻塞队列，线程安全的\n在队列为空时获取阻塞，在队列满时放入阻塞\nBlockingQueue方法以四种形式出现，对于不能立即满但可能在将来某一时刻可以满足的操作，这四种形式的处理方式不同：第一种是抛出一个异常，第二种是返回一个特殊值（null或者false，具体取决与操作），第三种是在操作可以成功之前，无期限的阻塞当前线程，第四种是在放弃在给定的最大时间内阻塞。\n抛出异常 特殊值 阻塞 超时 插入 add(e) offer(e) put(e) offer(e,time,unit) 移除 remove(e) poll() take() poll(time,unit) 检查 element() peek() 不可用 不可用 代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 public class FixedSizeThreadPool { //任务Runnable //仓库 private BlockingQueue\u0026lt;Runnable\u0026gt; taskQueue; //工作线程 private List\u0026lt;Worker\u0026gt; workers; private volatile boolean isWorking = true; public FixedSizeThreadPool(int poolSize, int queueSize) { taskQueue = new LinkedBlockingQueue\u0026lt;\u0026gt;(queueSize); workers = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; poolSize; i++) { Worker worker = new Worker(this); worker.start(); workers.add(worker); } } //提交任务到任务仓库 private boolean submit(Runnable task) { return taskQueue.offer(task); } private void shutdown() { /*关闭线程池 1.线程池不再接收新的任务 2.将提交的任务执行完成 */ this.isWorking = false; //结束线程的时候已经有线程阻塞了,就无法结束线程 //遍历线程,如果线程是阻塞的状态,停止线程,如果线程是运行状态,不能停止线程 workers.forEach(thread -\u0026gt; { if (thread.getState() == Thread.State.BLOCKED || thread.getState() == Thread.State.WAITING || thread.getState() == Thread.State.TIMED_WAITING) { //停止线程 //中断线程的阻塞,等待状态 thread.interrupt(); } }); } private static class Worker extends Thread { FixedSizeThreadPool pool; public Worker(FixedSizeThreadPool pool) { this.pool = pool; } @Override public void run() { while (pool.isWorking || pool.taskQueue.size() \u0026gt; 0) { Runnable task = null; try { if (pool.isWorking) { task = pool.taskQueue.take(); } else { task = pool.taskQueue.poll(); } } catch (InterruptedException e) { throw new RuntimeException(e); } if (task != null) { task.run(); } } } } public static void main(String[] args) throws InterruptedException { FixedSizeThreadPool pool = new FixedSizeThreadPool(3, 6); for (int i = 0; i \u0026lt; 5; i++) { pool.submit(() -\u0026gt; { try { Thread.sleep(200L); } catch (InterruptedException e) { throw new RuntimeException(e); } System.out.println(Thread.currentThread().getName() + \u0026#34;任务执行完成\u0026#34;); }); } System.out.println(\u0026#34;任务全部提交到任务仓库\u0026#34;); Thread.sleep(700L); pool.shutdown(); } } 确定合适数量的线程 计算型任务 CPU数量的1-2倍\nIO型任务 需要多一些线程，要根据具体的IO阻塞时间考量决定，如tomcat中默认的最大的线程数为200，也可以根据需要在一个最小数量和最大数量之间自动递减线程数\n","date":"2022-04-12T00:00:00Z","permalink":"https://www.gpanda.me/p/%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E6%B1%A0/","title":"简单实现线程池"}]